---
layout: post
title: "Mysql实战原理四"
subtitle: '索引'
author: "Wbs"
header-style: text
tags:
  - Mysql
---

> 极客时间日常学习总结之丁奇大佬Mysql实战<br/>
> 此篇是针对索引的总结

直接开门见山的总结了~

### 什么是索引?
> 可以理解为书的目录,通过目录我们可以很快速的查找到我们想要的东西。<br/>
> 索引的出现很大程度的优化了我们的查询效率。

文中作者介绍了三种常见的索引模型 

1. 哈希表
2. 有序数组
3. 搜索树


### 哈希表
> 适用于等值查询,kv形式,如果你学过java 可以理解为Map,key为hash值,value为一个数组。key是通过hash运算后得到一个哈希值(这个值不唯一,可能多个值通过运算得到相同的hash值)。针对相同的hash值的数据会放在其内部链表。
> 如果key相同的话,他会通过特定的转换将key转换为指定的值,拿着这个值取特定的value。<br/> <br/>
> 再说下优缺点。谈到链表,第一想到的是增删快- -。没错哈希表索引也是增删快,他不需要维护key的有序性,有数据就追加。但是对于有区间限制的查询还是痛点,因为它并没有保证数据的顺序行,在区间查询时需要取值一个个来判断。

### 有序数组
> 适用于查询(等值或者区间查询)。
> 优缺点的话就是查询快,增删慢(需要维持数据的有序性)。

### 搜索树
> * 二叉树(每一个父节点有两个子节点 左节点小于父节点 父节点小于右节点) 二叉树不仅要对内存操作,还要对磁盘操作(涉及到IO操作 就很蛋疼了- -很慢,如果说树高很高的话,一次查询如果查询很深那么就需要多次进行io操作,耗时肯定是不可能接受的 - -)。
> * N叉树 很大程度的减少IO操作

### InnoDB的索引
> InnoDB的索引类型为B+树,数据都存储在B+树种。<br/><br/>
> 每个索引对应一个B+树

B+索引具体还可以分为

* 主键索引

* 非主键索引

> 两者有什么区别呢？<br/><br/>
> 主键索引下的数据存储的是整行的数据
> 而非主键索引存储的是主键ID,当使用非主键作为条件查询的时候,得到的是主键ID,此时查询还需要拿ID在去主键索引树再次查询得到数据(这个过程被称为回表)。<br/><br/>
> 那还会有个疑问如果表中没有主键怎么办呢？<br/>
> mysql在创建表的时候如果没有指定主键,InnoDB默认生成一个rowId作为主键

### 索引的维护
* 页分裂(当数据页满了,需要申请新的数据页存放数据)

* 合并(数据删除时,页有空的空间,需要将页数据合并)


### Mysql的索引特性

* 覆盖索引

	> 可以减少回表,从而提升查询效率。<br/>SELECT ID FROM T WHERE INDEX\_COL 
	> 其中ID为主键,INDEX\_COL 为索引列 而此时INDEX_COL已经包含了ID的值,所以就不会再回表查询。
* 最左原则

* 索引下推
	> MySQL 5.6之前建立联合索引的表,在查询包含索引列的值时需要回表查询,但5.6之后需要回表但是减少了回表的次数,在取列值得时候已经做出了判断,过滤掉了不符合条件的数据<br/>
	> 比如说 ```create table student(id int primary key ,name varchar,age int,key name_age ('name','age')```我现在想过滤掉name为w开头并且age大于18岁的学生sql语句应该为 ```SELECT * from student where name like'w%' and age > 18 ```
	**5.6之前**数据会进行如下操作,首先会查找名称以w开头的数据,然后拿到这批数据的主键id,去主键树查找对应的行数据,在比较age 筛选age 大于18岁的数据<br/>
	>在**5.6之后** 首先name和age是联合索引,在第一次查询name是w开头的数据的时候已经顺带查找出了age的值,在此时mysql就已经开始判断了age的值,不符合就直接过滤掉。极大的减少了回表的次数。

总结到这里,回想到之前的项目应该还是有些地方还可以优化🙄只怪与这个专栏相逢甚晚啊- -,有机会一定要在实战中实践一下。
