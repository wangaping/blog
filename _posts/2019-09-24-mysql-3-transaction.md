---
layout: post
title: "Mysql实战原理三"
subtitle: 'mysql的事物之隔离性'
author: "Wbs"
header-style: text
tags:
  - Mysql
---
> 极客时间日常学习总结之丁奇大佬Mysql实战<br/>
> 此篇是针对与Mysql的事务总结

说到事务不由自主的就想到转账！几乎是最经典的案例了~！

### 那么什么是事物呢？
> ***事物其实就是保证一组数据库操作,要么全部成功,要么全部失败!***

### 事务的特性
> 1. 原子性
> 2. 一致性
> 3. 隔离性
> 4. 持久性

今天这篇文章主要对丁奇作者讲的隔离性做一个总结！

### 为什么会有隔离性?
> 数据库有多个事务同时执行可能会出现脏读、幻读、不可重复读等问题。

### 隔离级别
> 为了解决上面隔离性的问题,就出现了隔离级别。

***隔离级别的出现会引发一个问题就是数据的安全和执行的效率的问题(因为鱼和熊掌不可兼得嘛~)<br/>***

***Mysql默认的隔离级别是可重复读 可以使用命令```select @@transaction_isolation;```查看。<br/>一般推荐使用读提交的方式```set tx_isolation = 'READ-COMMITTED';
```***
> * 读未提交(read uncommited)
> * 读提交(read commited)
> * 可重复读(repeatable read)
> * 串行化(serializable)<br/>
> 
>下面对这些隔离级别做出解释(均以A、B两个连接对表T的操作来举例说明)

***读未提交***
> A对表T的(未提交)操作对于B是可见的

***读提交***
> A对表T的操作得在commit之后B才可以看见

***可重复读***
> A在查询表T的同时B在更新表T,但是A看到的始终是B操作之前的数据(解释下为什么会这样因为在事物开始的时候mysql会创建一个只读的视图,所以A后面查看的数据均是视图操作)

***串行化***
> A对表T做操作的会加锁,B的操作需要等待A的操作完成事物提交后才可以进行



### 事物隔离的实现
> 说道事物隔离的实现其实主要是因为版本并发控制(MVCC),你的每一次操作都对应着一次回滚日志。对应每次修改都有一个对应的read view。<br/><br/>
> ***那么如果说对一个字段的修改很多次,就会对应很多的回滚日志,岂不是要浪费很多磁盘空间(因为每次都会写入回滚日志)***？<br/>
> 其实mysql也会对回滚日志进行删除的,就已版本为例,你对表T的字段操作依次为v1、v2、v3,
> 那么mysql就会检查当前版本是否为最老版本(当前版本之前再无版本)。如果说判断为最老版本,则会进行删除。


***额外说明下 可以使用命令查看事务是手动提交还是自动提交```select @@autocommit;``` 推荐使用 autocommit=1的方式手动启动***
